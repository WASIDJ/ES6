1. 支持`0o`和`0b`前缀的八进制和二进制数字
2. 支持数值分隔符 `_` 来提高可读性
## 常见的`Math`对象方法

| 方法 | 说明 |案例|
|---|---|---|   
|Math.trunc(x)|返回数值的整数部分，去掉小数部分|Math.trunc(4.9) // 4|
|Math.sign(x)|判断数值的正负，返回1（正数）、-1（负数）、0（正零）、-0（负零）|Math.sign(-5) // -1|
|Math.cbrt(x)|返回数值的立方根|Math.cbrt(27) // 3|
|Math.clz32(x)|`count leading zero bits in 32-bit binary representation of a number`返回数值的32位无符号整数形式的二进制表示中前导零的数量|Math.clz32(1) // 31|
|Math.imul(a, b)|返回两个数的32位整数乘积(为了提高精度计算|Math.imul(2, 4) // 8|
|Math.fround(x)|返回数值的32位单精度浮点数形式|Math.fround(1.337) // 1.3370000123977661|
|Math.hypot(...values)|返回所有参数的平方和的平方根|Math.hypot(3, 4) // 5|
|Math.expm1(x)|返回`e^x - 1`的值|Math.expm1(1) // 1.718281828459045|
|Math.log1p(x)|返回`ln(1 + x)`的值|Math.log1p(1) // 0.6931471805599453|
|Math.log10(x)|返回以10为底的对数值|Math.log10(100) // 2|
|Math.log2(x)|返回以2为底的对数值|Math.log2(8) // 3|
|Math.sinh(x)|返回数值的双曲正弦值|Math.sinh(0) // 0|
|Math.cosh(x)|返回数值的双曲余弦值|Math.cosh(0) // 1|
|Math.tanh(x)|返回数值的双曲正切值|Math.tanh(0) // 0|
### `BigInt`类型
- `BigInt` 是一种内置对象，提供了一种方式来表示大于 `2^53 - 1` 的整数。
- 通过在整数后面添加 `n` 来创建一个 `BigInt`。
## NOTE
---
1. `Number.parseInteger(25)`和 `Number.parseInteger(25.0)` 都是 `true` .`JavaScript` 内部，整数和浮点数采用的是同样的储存方法.
2. `Number.EPSILON` $2^{-52}$[^1] 是 `JavaScript` 能够区分的最小数值差异. 也就是说, 如果两个数值的差异小于 `Number.EPSILON`, 那么它们在 `JavaScript` 中会被认为是相等的.目的手动设置一个 误差范围, 解决浮点数运算的精度问题.
3. 超过 $2^{53}$ 的整数, `Number.isInteger` 会误判(不安全了).这个数超出了精度范围，导致在计算机内部，以 `9007199254740992`的形式储存。
## 拓展
### []Q1: 精度丢失
由于 JavaScript 采用 `IEEE 754` 标准，数值存储为 64 位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第 54 位及后面的位就会被丢弃，这种情况下，`Number.isInteger`  可能会误判。
```js
Number.isInteger(3.0000000000000002) // true
```
- 问题
    1. 1 个隐藏位与 52 个有效位 如何确定?具体作用我完全没概念

### []Q2: `+0`和`-0` 为什么会出现?(可以作为视频脚本介绍)
- 如果出现 `+0` 和 `-0` ,就意味同时生成`-inf` 和 `+inf` 两个无穷大.少表示了两个数值,这种冗余为了得到什么?
### []Q3: `asm.js` 在干什么?

# 注释
[^1]: 为什么是 $$2^{-52}$$ ? 看你的系统位数