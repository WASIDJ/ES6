# 使用模块
| 模块 | 说明 |
| --- | --- |
| @babel/cli | Babel 的命令行工具 |
| @babel/core | Babel 的核心库 |
| @babel/node | Babel 的 Node.js 运行时 |
| @babel/register | Babel 的注册器，用于在运行时动态编译模块 |
# babel/cli 常用命令
```sh
npx babel example.js -o compiled.js
npx babel src --out-dir dist
```

# Let & Var & Const
- `let`and `const`: 块级作用域，不能在块级作用域外部访问,不会发生变量提升
- `var`: 函数作用域，在函数作用域外部也可以访问


## 常见概念
- 变量提升: 变量在声明之前就可以访问,但是值为`undefined`
- 暂时性死区（temporal dead zone，简称 TDZ）: 如果区块中存在`let`和`const`命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
```js
var tmp=123;
if(true){
    tmp=456; // ReferenceError
    let tmp;
}
```
### ES6的6种声明的方式
| 声明方式 | 作用域 | 变量提升 | 是否可修改 |
| --- | --- | --- | --- |
| var | 函数作用域 | 会 | 可以 |
| let | 块级作用域 | 不会 | 可以 |
| const | 块级作用域 | 不会 | 不能 |
| function | 函数作用域 | 会 | 可以 |
| class | 块级作用域 | 不会 | 不能 |
| import | 模块作用域 | 不会 | 不能 |

### 顶层对象属性
- 在浏览器环境，顶层对象是`window`，在 Node 环境，顶层对象是`global`。
- 顶层对象的属性与全局变量挂钩，被认为是 `JavaScript` 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，`window`对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。
- `var`命令和``function``命令声明的全局变量，依旧是顶层对象的属性；但是`let`、`const`、`class`命令声明的全局变量，不属于顶层对象的属性。
## 常见错误
```js
// 浏览器的 ES6 环境
function f() { console.log('I am outside!'); }
(function () {
  var f = undefined;
  if (false) {
    function f() { console.log('I am inside!'); }
  }
  f();
}());
// Uncaught TypeError: f is not a function
```
- `{}`才被认为是一个块级作用域
- `const`实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
